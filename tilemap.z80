; Draw a tilemap to the screen
; What it does:
;	0. Center the map around the player's coordinates
;	1. Find our position in the gbuf and in our tilemap
;	2. Draw a row of the tilemap sprite by sprite
;	3. Loop until all rows have been drawn
drawMap:
	call isPlayerLeftEdge
	 jr nc, drawMapCheckRightEdge
		ld hl, 0
		ld (mapX), hl
		jr drawMapCheckTop
drawMapCheckRightEdge:
	call isPlayerRightEdge
	 jr nc, drawMapCenterX
		ld a, (mapW)
		sub SCREEN_WIDTH
		ld h, a
		ld l, 0
		ld (mapX), hl
		jr drawMapCheckTop
drawMapCenterX:
	ld hl, (playerX)
	ld bc, (SCREEN_WIDTH * ONE_TILE) / 2 - (4 * ONE_PIXEL)
	sbc hl, bc
	ld (mapX), hl
drawMapCheckTop:
	call isPlayerTopEdge
	 jr nc, drawMapCheckBottomEdge
		ld hl, 0
		ld (mapY), hl
		jr drawMapStart
drawMapCheckBottomEdge:
	call isPlayerBottomEdge
	 jr nc, drawMapCenterY
		ld a, (mapH)
		sub SCREEN_ROWS / 8
		ld h, a
		ld l, 0
		ld (mapY), hl
		jr drawMapStart
drawMapCenterY:
	ld hl, (playerY)
	ld bc, (SCREEN_ROWS * ONE_PIXEL) / 2 - (PLAYER_HEIGHT / 2 * ONE_PIXEL)
	sbc hl, bc
	ld (mapY), hl
drawMapStart:
	ld hl, mapX + 1			; MSB of mapX, this byte will be byte-aligned
	ld c, (hl)				;
	ld b, 0					; bc = mapX
	inc hl					; skip to MSB of mapY
	inc hl					; 
	ld e, (hl)				; e = mapY
	inc hl					; &mapW
	ld h, (hl)				; h = mapW
	call multEH				; hl = mapW * mapY
	ld de, (mapPtr)
	add hl, de
	add hl, bc				; hl = map + x offset
	ex de, hl				; de = starting position in tilemap
	ld hl, gbuf
	ld c, GBUF_ROWS / 8		; number of sprites per column

drawMapRow:
	ld b, GBUF_WIDTH		; number of sprites per row

; This inner loop is run hundreds of times per frame, so we want it to be
; as fast as possible.
drawMapSprite:
	push hl					; hl = gbuf position
	push de					; de = position in tilemap
	push bc					; b = num sprites per row
		ld c, l				; save hl
		ld b, h				; bc = gbuf position
; find the address of the sprite from its ID
		ld a, (de)			; get sprite number
		ld l, a
		ld h, 0
		add hl, hl			; * 2
		add hl, hl			; * 4
		add hl, hl			; hl * 8
		ld de, tileData		;
		add hl, de			; hl = sprite pointer
		ex de, hl			; de = sprite pointer
		ld l, c				; restore hl
		ld h, b				; hl = position in gbuf
		ld bc, GBUF_WIDTH
; copy from sprite data to gbuf
		ld a, (de)			; 1: sprite byte
		ld (hl), a			; store in gbuf
		add hl, bc			; next row of gbuf
		inc de				; next row in sprite
		ld a, (de)			; 2
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 3
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 4
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 5
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 6
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 7
		ld (hl), a			;
		add hl, bc			;
		inc de				;
		ld a, (de)			; 8
		ld (hl), a			;
	pop bc					; b = current column in row of tilemap sprites
	pop de					; de = position in tilemap
	pop hl					; hl = position of gbuf
	inc hl					; next column of gbuf
	inc de					; next tile in tilemap
	djnz drawMapSprite
; update gbuf and tilemap pointers to go to next row
	push bc
		ld c, GBUF_WIDTH * 7	; we've drawn one row, hl is pointing to 2nd row of
		add hl, bc			; we need to move down 7 more rows (each tile is 8x8)
		ex de,hl			; hl = position in tilemap
		ld a, (mapW)		; now we need to jump down to the next row in our
		sub GBUF_WIDTH		; .. tilemap.
		ld c, a
		add hl, bc
		ex de,hl			; hl = gbuf position, de = tilemap position
	pop bc
	dec c
	 jp nz, drawMapRow
	ret

; Map Movement Routines
; Handle moving around the map.

mapLeft:
	ld de, -ONE_PIXEL
	ld hl, (mapX)			; get X pos in map
	add hl, de
	 jr c, $ + 5
		ld hl, 0
	ld (mapX), hl
	ret

mapRight:
	ld de, ONE_PIXEL
	ld hl, (mapX)			; X position in map
	add hl, de				; try to move right one pixel
	ld a, (mapW)			; width of map in tiles
	sub SCREEN_WIDTH + 1	; since X position starts at the left edge, we need to subtract screen width
							; .. to test if we're at the right edge of the map
	cp h					; h holds the byte/tile-aligned value
	inc a
	 jr nc, $ + 5			; test if h is pointing to the right edge of the screen
		ld h, a				; if so, make it stop at the right edge
		ld l, 0				;
	ld (mapX), hl			; save the new map position
	ret

mapUp:
	ld de, -ONE_PIXEL
	ld hl, (mapY)			; get Y pos in map
	add hl, de
	 jr c, $ + 5
		ld hl, 0
	ld (mapY), hl
	ret

mapDown:
	ld de, ONE_PIXEL
	ld hl, (mapY)			; similar to mapRight, just for Y values
	add hl, de
	ld a, (mapH)			; since on the screen we show SCREEN_ROWS / 8 tiles
	sub SCREEN_ROWS / 8 + 1	; .. (8x8, so 12 tiles), we need to subtract that from
	cp h					; .. mapH to make sure mapY and mapH are both pointing
	inc a					; to compensate for the + 1  we subtracted from mapH
	 jr nc, $ + 5			; check if we're at the edge or past it
		ld h, a				; if so, align to right edge of map
		ld l, 0
	ld (mapY), hl			; save new Y position
	ret
